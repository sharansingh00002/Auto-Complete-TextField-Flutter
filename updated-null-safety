library auto_complete_text_view;

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutterweb/constants.dart';
import 'package:flutterweb/utils/functions.dart';
import 'package:flutterweb/widgets/input/KTextField.dart';
import 'package:get/get.dart';
import 'package:rxdart/rxdart.dart';

typedef void OnTapCallback(String value);

class AutoCompleteTextView extends StatefulWidget
    with AutoCompleteTextInterface {
  final double maxHeight;
  final TextEditingController controller;

  //AutoCompleteTextField properties
  final tfCursorColor;
  final tfCursorWidth;
  final tfStyle;
  final tfTextDecoration;
  final tfTextAlign;
  //Suggestiondrop Down properties
  final TextStyle suggestionStyle;
  final suggestionTextAlign;
  final Function(String)? onTapCallback;
  final Function getSuggestionsMethod;
  final Function? focusGained;
  final Function? focusLost;
  final int suggestionsApiFetchDelay;
  final Function? onValueChanged;
  final String title;
  final bool required;

  AutoCompleteTextView(
      {required this.controller,
      this.onTapCallback,
      this.maxHeight = 200,
      this.tfCursorColor = Colors.white,
      this.tfCursorWidth = 2.0,
      this.tfStyle = const TextStyle(color: Colors.black),
      this.tfTextDecoration = const InputDecoration(),
      this.tfTextAlign = TextAlign.left,
      this.suggestionStyle = const TextStyle(color: Colors.black),
      this.suggestionTextAlign = TextAlign.left,
      required this.getSuggestionsMethod,
      this.focusGained,
      this.suggestionsApiFetchDelay = 0,
      this.focusLost,
      this.title = "",
      this.required = false,
      this.onValueChanged});
  @override
  _AutoCompleteTextViewState createState() => _AutoCompleteTextViewState();

  //This funciton is called when a user clicks on a suggestion
  @override
  void onTappedSuggestion(String suggestion) {
    if (onTapCallback != null) onTapCallback!(suggestion);
  }
}

String isSelected = "";

class _AutoCompleteTextViewState extends State<AutoCompleteTextView> {
  ScrollController scrollController = ScrollController();
  FocusNode _focusNode = FocusNode();
  late OverlayEntry _overlayEntry;
  LayerLink _layerLink = LayerLink();
  final suggestionsStreamController = new BehaviorSubject<List<String>>();
  List<String> suggestionShowList = <String>[];
  Timer _debounce = Timer(Duration(milliseconds: 0), () {});
  bool isSearching = true;
  bool isLoading = false;
  @override
  void initState() {
    super.initState();
    isSelected = "";

    _focusNode.addListener(() {
      if (_focusNode.hasFocus) {
        this._overlayEntry = this._createOverlayEntry();
        Overlay.of(context)!.insert(this._overlayEntry);
        (widget.focusGained != null) ? widget.focusGained!() : () {};
      } else {
        this._overlayEntry.remove();
        (widget.focusLost != null) ? widget.focusLost!() : () {};
      }
    });
    widget.controller.addListener(_onSearchChanged);
  }

  _onSearchChanged() {
    try {
      if (_debounce?.isActive ?? false) _debounce.cancel();
      _debounce =
          Timer(Duration(milliseconds: widget.suggestionsApiFetchDelay), () {
        if (isSearching == true) {
          _getSuggestions(widget.controller.text);
        }
      });
    } catch (e) {
      if (isSearching == true) {
        _getSuggestions(widget.controller.text);
      }
    }
  }

  _getSuggestions(String data) async {
    if (data.length > 0 && data != null && isSelected == "") {
      List<String> list = await widget.getSuggestionsMethod(data);
      setState(() {
        isLoading = false;
        suggestionsStreamController.sink.add(list);
      });
    }
  }

  OverlayEntry _createOverlayEntry() {
    RenderObject? renderBox = context.findRenderObject();

    return OverlayEntry(
        builder: (context) => Positioned(
              width: Get.width,
              child: CompositedTransformFollower(
                link: this._layerLink,
                showWhenUnlinked: false,
                offset: Offset(0.0, 60 + 5.0),
                child: Material(
                  elevation: 4.0,
                  child: StreamBuilder<Object>(
                      stream: suggestionsStreamController.stream,
                      builder: (context, suggestionData) {
                        List<String> data = [];
                        bool hasData = false;
                        if (suggestionData.hasData) {
                          data = suggestionData.data as List<String>;
                          hasData = data.length > 0 &&
                              widget.controller.text.isNotEmpty;
                        }

                        if (hasData) {
                          suggestionShowList =
                              suggestionData.data as List<String>;
                          return Container(
                            constraints: new BoxConstraints(
                              maxHeight: 200,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(12.0),
                              border: Border.all(color: AppColors.kBlue),
                            ),
                            padding: const EdgeInsets.symmetric(
                                horizontal: 20.0, vertical: 10.0),
                            child: ListView.builder(
                                controller: scrollController,
                                padding: EdgeInsets.zero,
                                shrinkWrap: true,
                                itemCount: suggestionShowList.length,
                                itemBuilder: (context, index) {
                                  return ListTile(
                                    title: Text(
                                      suggestionShowList[index],
                                      style: widget.suggestionStyle,
                                      textAlign: widget.suggestionTextAlign,
                                    ),
                                    onTap: () {
                                      isSearching = false;
                                      isLoading = false;
                                      widget.controller.text =
                                          suggestionShowList[index];

                                      isSelected = widget.controller.text;
                                      suggestionsStreamController.sink.add([]);
                                      widget.onTappedSuggestion(
                                          widget.controller.text);
                                    },
                                  );
                                }),
                          );
                        } else {
                          return isSelected != ""
                              ? Container()
                              : isLoading
                                  ? ListTile(
                                      title: Text(
                                        "Loading...",
                                        style: widget.suggestionStyle,
                                        textAlign: widget.suggestionTextAlign,
                                      ),
                                      onTap: () {},
                                    )
                                  : !hasData &&
                                          widget.controller.text.isNotEmpty &&
                                          isSearching
                                      ? ListTile(
                                          title: Text(
                                            "No Departments Found",
                                            style: widget.suggestionStyle,
                                            textAlign:
                                                widget.suggestionTextAlign,
                                          ),
                                          onTap: () {},
                                        )
                                      : Container();
                        }
                      }),
                ),
              ),
            ));
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
        link: this._layerLink,
        child: KTextField(
            required: widget.required,
            title: widget.title,
            controller: widget.controller,
            focusNode: this._focusNode,
            onChange: (String text) {
              if (text.trim().isNotEmpty) {
                (widget.onValueChanged != null)
                    ? widget.onValueChanged!(text)
                    : () {};
                isSearching = true;
                isLoading = true;
                if (isSelected != widget.controller.text) isSelected = "";
                if (scrollController.hasClients) {
                  scrollController.animateTo(
                    0.0,
                    curve: Curves.easeOut,
                    duration: const Duration(milliseconds: 300),
                  );
                }

                setState(() {});
              } else {
                isSearching = false;
                isLoading = false;
                suggestionsStreamController.sink.add([]);
              }
            }));
  }

  @override
  void dispose() {
    suggestionsStreamController.close();
    scrollController.dispose();
    widget.controller.dispose();
    super.dispose();
  }
}

abstract class AutoCompleteTextInterface {
  void onTappedSuggestion(String suggestion);
}



// ignore_for_file: file_names
// CUSTOM TEXTFIELD
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutterweb/constants.dart';
import 'package:flutterweb/main.dart';
import 'package:flutterweb/widgets/builders/customAppBar.dart';

class KTextField extends StatefulWidget {
  final TextEditingController? controller;
  final String title;
  final String hintText;
  final bool? obscureText;
  final bool readOnly;
  final double verticalPadding;
  final TextInputType? keyboardType;
  final Function(String)? onChange;
  final EdgeInsetsGeometry? margins;
  final double height;
  final double? width;
  final bool required;
  final bool isLoading;
  final FocusNode? focusNode;
  final List<TextInputFormatter>? inputFormatters;

  const KTextField(
      {Key? key,
      this.controller,
      required this.title,
      this.hintText = "Enter here",
      this.obscureText,
      this.readOnly = false,
      this.verticalPadding = 2.0,
      this.margins = const EdgeInsets.fromLTRB(0, 0, 0, 0),
      this.keyboardType,
      this.height = 60,
      this.required = false,
      this.inputFormatters,
      this.focusNode,
      this.width,
      this.isLoading = false,
      this.onChange})
      : super(key: key);

  @override
  State<KTextField> createState() => _KTextFieldState();
}

class _KTextFieldState extends State<KTextField> {
  bool _isVisible = true;

  void showToast() {
    setState(() {
      _isVisible = !_isVisible;
    });
  }

  @override
  Widget build(BuildContext context) {
    Color _getTitleColor() {
      if (widget.required) return AppColors.kRed;

      if (widget.readOnly == true) return Colors.grey;

      return AppColors.kBlue;
    }

    Color _getBorderColor() {
      if (widget.required) return AppColors.kRed;

      return AppColors.kBlue;
    }

    return Container(
      height: widget.height,
      width: widget.width ?? app_width,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12.0),
        border: Border.all(
          color: _getBorderColor(),
          width: 3,
        ),
      ),
      padding: EdgeInsets.symmetric(
          horizontal: 20.0, vertical: widget.verticalPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          TextFormField(
            focusNode: widget.focusNode,
            controller: widget.controller,
            obscureText: _isVisible && (widget.obscureText ?? false),
            readOnly: widget.readOnly,
            keyboardType: widget.keyboardType,
            inputFormatters: widget.inputFormatters,
            onChanged: (String t) {
              if (widget.onChange != null) widget.onChange!(t);
            },
            decoration: InputDecoration(
              enabledBorder: InputBorder.none,
              focusedBorder: InputBorder.none,
              disabledBorder: InputBorder.none,
              labelText: widget.isLoading ? "Loading..." : widget.title ?? "",
              floatingLabelStyle: TextStyle(
                color: _getTitleColor(),
                fontWeight: FontWeight.w600,
                fontSize: 15.0,
              ),
              enabled: !widget.readOnly,
              hintStyle: kTextFieldStyle,
              suffixIconConstraints:
                  const BoxConstraints.tightFor(height: 25.0, width: 25.0),
              contentPadding: const EdgeInsets.only(top: 2, bottom: 2),
            ),
          )
        ],
      ),
    );
  }
}
